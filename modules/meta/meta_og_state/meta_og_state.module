<?php

/**
 * @file
 * Enable access control for Open and Close groups and group content.
 */

/**
 * The access realm of group member.
 */
define('META_OG_STATE_REALM', 'meta_og_state');

/**
 * Group state field.
 */
define('META_OG_STATE_FIELD', 'meta_og_state_state');


/**
 * Define group access as OPEN.
 */
define('META_OG_STATE_DRAFT', 0);

/**
 * Define group access as CLOSE.
 */
define('META_OG_STATE_PUBLISHED', 1);



function meta_og_state_init() {
  //node_access_rebuild();
}

/**
 * Implements hook_node_grants().
 */
function meta_og_state_node_grants($account, $op) {
  if ($op != 'view') {
    return;
  }
  $groups = array(
    'node' => array()
  );
  if (user_access('administer group', $account)) {
    $groups = og_get_all_group();
  } else {
    $groups = og_get_entity_groups('user', $account);
  }
  
  $grants = array();
  foreach ($groups as $group_type => $gids) {
    foreach ($gids as $gid) {
      $node = node_load($gid);
      // if user is the owner of admin user for the group give them the key
      if ($node->uid == $account->uid || og_user_access('node', $gid, 'view draft', $account)) {
        $realm = META_OG_STATE_REALM;
        $grants[$realm][] = $gid;
      }
    }
  }
  return $grants;
}

/**
 * Implements hook_node_access_records().
 */
function meta_og_state_node_access_records($node) {
  if (empty($node->status)) {
    // Node is unpublished, so we don't allow every group member to see
    // it.
    return array();
  }

  // make sure that this is a group
  if (!og_is_group('node', $node->nid)) {
    return array();
  }
  $gid = $node->nid;
  $state = _meta_og_state_get_state($node);
  $grants = array();
  if ($state == META_OG_STATE_DRAFT) {
    // we just for Draft state right now. We can handle other states if there are any, here.
    // we just care about 'view' grant. other grants are being handled right now by default permissions.
    $grants[] = array(
      'realm' => META_OG_STATE_REALM,
      'gid' => $gid,
      'grant_view' => 1,
      'grant_update' => 0,
      'grant_delete' => 0,
      'priority' => 0,
    );
  }
  return $grants;
}

/**
 * Checking if the node is part of a Close group.
 */

function _meta_og_state_get_state($node) {
  $gid = $node->nid;
  if (!og_is_group('node', $gid)) {
    return false;
  }
  $group_wrapper = entity_metadata_wrapper('node', $gid);
  if (isset($group_wrapper->{META_OG_STATE_FIELD})) {
    return $group_wrapper->{META_OG_STATE_FIELD}->value();
  }
  return false;
}

/**
 * 
*/
function meta_og_state_is_draft($gid) {
  $group_wrapper = entity_metadata_wrapper('node', $gid);
  if (isset($group_wrapper->{META_OG_STATE_FIELD})) {
    return $group_wrapper->{META_OG_STATE_FIELD}->value() == META_OG_STATE_DRAFT;
  }
  return null;
}


/**
 * Implement hook_og_permission().
 */
function meta_og_state_og_permission() {
  $items = array();
  $items['view draft'] = array(
    'title' => t('View in Draft state'),
    'description' => t('Allow users to view the group in Draft mode.'),
    'default role' => array(OG_ADMINISTRATOR_ROLE),
    'restrict access' => TRUE,
  );
  return $items;
}


/**
 * Implement hook_og_fields_info().
 */
function meta_og_state_og_fields_info() {
  $allowed_values = array(
    META_OG_STATE_DRAFT => 'Draft',
    META_OG_STATE_PUBLISHED =>  'Published',
  );
  $items[META_OG_STATE_FIELD] = array(
    'type' => array('group'),
    'description' => t('Determine the state of a group.'),
    // Open state can be done only on node entity.
    'entity' => array('node'),
    'field' => array(
      'field_name' => META_OG_STATE_FIELD,
      'no_ui' => TRUE,
      'type' => 'list_boolean',
      'cardinality' => 1,
      'settings' => array('allowed_values' => $allowed_values, 'allowed_values_function' => ''),
    ),
    'instance' => array(
      'label' => t('Group state'),
      'required' => TRUE,
      // Default to draft.
      'default_value' => array(0 => array('value' => META_OG_STATE_DRAFT)),
      'widget_type' => 'options_select',
      'view modes' => array(
        'full' => array(
          'label' => 'above',
          'type' => 'options_onoff',
        ),
        'teaser' => array(
          'label' => 'above',
          'type' => 'options_onoff',
        ),
      ),
    ),
  );
  return $items;
}



/**
 * Implementation of hook_field_access().
 *
 * @param $op
 *   The operation to be performed. Possible values:
 *   - 'edit'
 *   - 'view'
 * @param $field
 *   The field on which the operation is to be performed.
 * @param $entity_type
 *   The type of entity; e.g. 'node' or 'user'.
 * @param $entity
 *   The entity on which the operation is to be performed.
 * @param $account
 *   The account to check.
 *
 * @return
 *   FALSE if the operation is not allowed.
 *   Note when field_access() is invoked, access is granted unless one
 *   implementation of hook_field_access() explicitly returns FALSE.
 *
 * @see field_access()
 */
function meta_og_state_field_access($op, $field, $entity_type, $entity, $account) {
  if ($field['field_name'] != META_OG_STATE_FIELD) {
    return;
  }

  if (user_access('administer group')) {
    return TRUE;
  }

  // users should now the state!
  if ($op == 'view') {
    return;
  }

  if (user_access('bypass node access', $account)) {
    return true;
  }
  if (user_access('administer group', $group)) {
    return true;
  }
  return false;
}

function meta_og_state_form_node_form_alter(&$form, &$form_state) {
  if (!isset($form_state['node']->nid)) { // new node
    $form['meta_og_state_state']['und']['#required'] = false;
  } 
}




